<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90ccbcb3fe07f548327e1919c5fa54fecbde32ba" /><Meta Name="ms.sourcegitcommit" Value="9e48edef9d279c87fa2fbd78f150bc92c2332179" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/13/2021" /><Meta Name="ms.locfileid" Value="51691749" /></Metadata><TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hierbei handelt es sich um eine primäre Schnittstelle in einer COM-CoClass, die von verwaltetem Code benötigt wird, um Interoperabilität mit dem entsprechenden COM-Objekt sicherzustellen. Verwenden Sie diese primäre Schnittstelle nur, wenn die Methode, die Sie verwenden möchten, den gleichen Namen aufweist wie ein Ereignis des COM-Objekts; casten Sie in diesem Fall zu dieser Schnittstelle, um die Methode aufzurufen, und casten Sie zur aktuellen Ereignisschnittstelle, um eine Verbindung zum Ereignis herzustellen. Verwenden Sie andernfalls die von der COM-CoClass abgeleitete .NET-Schnittstelle, um auf Methoden, Eigenschaften und Ereignisse des COM-Objekts zuzugreifen. Weitere Informationen zum COM-Objekt finden Sie unter <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> .</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">Outlook-Elementtyp für das neue Element. Gibt ein <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> an, um benutzerdefinierte Formulare zu erstellen. Kann eine der folgenden <b>OlItemType</b> -Konstanten sein: <b>OlAppointmentItem</b>, <b>OlContactItem</b>, <b>OlJournalItem</b>, <b>OlMailItem</b>, <b>OlNoteItem</b>, <b>OlPostItem</b> oder <b>OlTaskItem,</b> oder eine beliebige gültige Nachrichtenklasse.</param>
        <summary>Erstellt ein neues Outlook-Element in der <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> Auflistung für den Ordner.</summary>
        <returns>Ein Objektwert, der das neue Outlook-Element darstellt.</returns>
        <remarks><para>Wenn die Type-Eigenschaft des Outlook-Elements nicht angegeben wird, wird standardmäßig der Typ des Ordners oder der übergeordnete Ordner nicht <b></b> <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /> typiert.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt ein <see cref="T:Microsoft.Office.Interop.Outlook.Application" />  Objekt zurück, das die übergeordnete Outlook-Anwendung für das Objekt darstellt. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> Konstante zurück, die die Klasse des Objekts angibt. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen <b>Wert vom Typ Integer</b> (<b>int</b> in C#) zurück, der die Anzahl der Objekte in der angegebenen Auflistung angibt. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Eine Zeichenfolge, die die Kriterien angibt, die das zurückgegebene Objekt erfüllen muss.</param>
        <summary>Sucht und gibt ein Outlook-Elementobjekt zurück, das dem angegebenen <paramref name="Filter" /> entspricht.</summary>
        <returns>Ein Object-Wert, der ein #A0 darstellt, wenn der Aufruf erfolgreich ist. gibt <b>Nothing</b> (ein Nullverweis (Nothing in Visual Basic) in C#) zurück, wenn ein Fehler auftritt.</returns>
        <remarks><para>Verwenden Sie die Methode, um die Inhaltsindizierungssuche in <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> der Auflistung <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> zu verwenden. <b>FindRow</b> gibt einen Fehler zurück, wenn <paramref name="Filter" /> schlüsselwörter für die Inhaltsindizierung enthalten sind. Weitere Informationen zu Schlüsselwörtern für die Inhaltsindizierung finden Sie <a href="http://go.microsoft.com/fwlink/?LinkId=87947">unter Filtern von Elementen mithilfe von Abfrageschlüsselwörtern.</a></para>
          <para>Die Methode gibt einen Fehler mit den folgenden Eigenschaften in der <paramref name="Filter" /> zurück: </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Filter für die Suchen und Einschränken-Methode erstellen</para>
          <para>Die Syntax für den Filter variiert je nach dem Typ des Felds, das Sie filtern möchten.</para>
          <para>String (für Textfelder) </para>
          <para>Beim Durchsuchen von Textfeldern können Sie entweder ein Apostroph (') oder doppelte Anführungszeichen ("") verwenden, um die Werte zu trennen, die Teil des Filters sind. Beispielsweise funktionieren alle folgenden Zeilen ordnungsgemäß, wenn das Feld vom Typ <b>String</b> (<b>string</b> in C#): </para>
          <para>sFilter = "[CompanyName] = 'Microsoft'" </para>
          <para>sFilter = "[CompanyName] = ""Microsoft""" </para>
          <para>sFilter = "[CompanyName] = " &amp; Chr(34) &amp; "Microsoft" &amp; Chr(34)</para>
          <para>Wenn Sie beim Angeben eines Filters in einer Jet- oder DASL-Abfrage ein Paar einfache Anführungszeichen zum Trennen einer Zeichenfolge verwenden, die Bestandteil des Filters ist, und diese Zeichenfolge ein weiteres einfaches Anführungszeichen oder Apostroph enthält, müssen Sie ein weiteres einfaches Anführungszeichen vor dem zusätzlichen einfachen Anführungszeichen bzw. Apostroph als Escapezeichen hinzufügen. Gehen Sie ähnlich vor, wenn ein Paar doppelte Anführungszeichen zum Trennen einer Zeichenfolge verwendet wird. Enthält die Zeichenfolge bereits ein doppeltes Anführungszeichen, fügen Sie ein weiteres doppeltes Anführungszeichen als Escapezeichen vor diesem doppelten Anführungszeichen hinzu.</para>
          <para>In der DASL-Filterzeichenfolge, die nach der <b>Subject-Eigenschaft</b> filtert, die dem Wort entspricht, ist die gesamte Filterzeichenfolge beispielsweise durch ein Paar doppelter Anführungszeichen getrennt, und die eingebettete Zeichenfolge kann nicht durch ein Paar einzelner Anführungszeichen getrennt werden. Es gibt drei Zeichen, die Sie in dieser Filterzeichenfolge escapen müssen: das startende doppelte Anführungszeichen und das endende doppelte Anführungszeichen für den Eigenschaftenverweis von , und das Apostroph in der Wertbedingung für das Wort kann http://schemas.microsoft.com/mapi/proptag/0x0037001f nicht. Durch Anwendung der geeigneten Escapezeichen kann die Filterzeichenfolge wie folgt ausgedrückt werden:</para>
          <para>filter = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f "" = 'can''t'"</para>
          <para>Alternativ können Sie die chr(34)-Funktion verwenden, um das doppelte Anführungszeichen darzustellen (dessen ASCII-Zeichenwert "34" ist), das als Escapezeichen verwendet wird. Unter Verwendung der chr(34)-Ersetzung für ein doppeltes Anführungszeichen als Escapezeichen können Sie das letzte Beispiel wie folgt ausdrücken:</para>
          <para>filter = "@SQL= " &amp; Chr(34) &amp; " " http://schemas.microsoft.com/mapi/proptag/0x0037001f _</para>
          <para>    &amp; Chr(34) &amp; " = " &amp; "'can't'"</para>
          <para>Das Escapen von einfachen und doppelten Anführungszeichen ist ebenfalls in DASL-Abfragen mit den Operatoren <b>ci_startswith</b> und <b>ci_phrasematch</b> erforderlich. Folgende Abfrage führt beispielsweise eine Begriffvergleichsabfrage für can't im Nachrichtenbetreff aus: </para>
          <para>filter = "@SQL=" &amp; Chr(34) &amp; " http://schemas.microsoft.com/mapi/proptag/0x0037001E " _</para>
          <para>    &amp; Chr(34) &amp; " ci_phrasematch " &amp; "'can't'"</para>
          <para>Ein weiteres Beispiel ist eine DASL-Filterzeichenfolge, die filtert, dass die <b>Subject-Eigenschaft</b> den Wörtern entspricht, die dem richtigen Zeug entspricht, wobei das Wortzeug durch doppelte Anführungszeichen eingeschlossen wird. In diesem Fall müssen die umschließenden doppelten Anführungszeichen wie folgt escapet werden:</para>
          <para>filter = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f "" = 'the right ""stuff""'"</para>
          <para>Ein anderer Satz von Escaperegeln gilt für Eigenschaftenverweise bei benannten Eigenschaften, die ein Leerzeichen, ein einfaches oder ein doppeltes Anführungszeichen enthalten. Weitere Informationen finden Sie unter Eigenschaften nach Namespace referenzieren.</para>
          <para>Datum</para>
          <para>Obwohl Datums- und Uhrzeitangaben in der Regel mit einem Date-Format gespeichert werden, erfordern die Methoden Suchen und Einschränken, dass Datum und Uhrzeit in eine Zeichenfolgendarstellung konvertiert werden. Um sicherzustellen, dass das Datum wie von Microsoft Outlook erwartet formatiert ist, verwenden Sie die Funktion Format. The following example creates a filter to find all contacts that have been modified after January 15, 1999 at 3:30 P.M. </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; Format("1/15/99 15:30pm", "ddddd h:nn AMPM") &amp; "'"</para>
          <para>Boolesche Operatoren</para>
          <para>Operatoren vom Typ Boolean (TRUE/FALSE, YES/NO, ON/OFF usw.) dürfen nicht in eine Zeichenfolge konvertiert werden. Wenn Sie z. B. ermitteln möchten, ob das Journal für Kontakte aktiviert ist, können Sie den folgenden Filter verwenden:</para>
          <para>sFilter = "[Journal] = True" </para>
          <para>
            <b>Hinweis</b>: Wenn Sie Anführungszeichen als Trennzeichen mit booleschen Feldern verwenden, findet eine leere Zeichenfolge Elemente, deren Felder False sind, und alle nicht leeren Zeichenfolgen finden Elemente, deren Felder True sind.</para>
          <para>Keywords (oder Categories)</para>
          <para>Das Feld Categories ist von Typschlüsselwörtern, die mehrere Werte enthalten sollen. When accessing it programmatically, the Categories field behaves like a Text field, and the string must match exactly. Values in the text string are separated by a comma and a space. This typically means that you cannot use the Find and Restrict methods on a keywords field if it contains more than one value. For example, if you have one contact in the Business category and one contact in the Business and Social categories, you cannot easily use the Find and Restrict methods to retrieve all items that are in the Business category. Instead, you can loop through all contacts in the folder and use the Instr function to test whether the string "Business" is contained within the entire keywords field. </para>
          <para>
            <b>Hinweis</b>: Eine mögliche Ausnahme ist, wenn Sie das Feld Kategorien auf zwei oder eine niedrige Anzahl von Werten beschränken. Anschließend können Sie die Methoden Find und Restrict mit dem logischen Operator OR verwenden, um alle Geschäftskontakte abzurufen. Zum Beispiel (im Pseudocode): "Unternehmen" oder "Unternehmen, persönlich" oder "Persönlich, Unternehmen" Bei Kategoriezeichenfolgen wird nicht zwischen Groß- und Kleinschreibung unterschieden.</para>
          <para>Ganze Zahl</para>
          <para>Das Durchsuchen von Feldern vom Typ Integer ist sowohl mit als auch ohne Anführungszeichen und Trennzeichen möglich. Mithilfe folgender Filter wird nach Kontakten gesucht, die in Outlook 2000 erstellt wurden: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = '92711'"</para>
          <para>Verwenden von Variablen in Filtern</para>
          <para>Wie das Beispiel der Restrict-Methode veranschaulicht, können Sie Werte aus Variablen als Teil des Filters verwenden. Im folgenden Microsoft Visual Basic Codebeispiel wird die Syntax veranschaulicht, die Variablen als Teil des Filters verwendet. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para> Bei diesem Ansatz wird Chr(34) verwendet, um den Wert zu trennen: sFilter = "[FullName] = " &amp; Chr(34) &amp; sFullName &amp; Chr(34) </para>
          <para> Bei diesem Ansatz werden doppelte Anführungszeichen verwendet, um den Wert zu trennen: sFilter = "[FullName] = """ &amp; sFullName &amp; """"</para>
          <para>Verwenden von logischen Operatoren als Teil des Filters</para>
          <para>Logische Operatoren, die zulässig sind, sind UND, ODER und NICHT. Im Folgenden finden Sie Variationen der Klausel für die Restrict-Methode, sodass Sie mehrere Kriterien angeben können.  </para>
          <para>OR: Der folgende Code gibt alle Kontaktelemente zurück, deren Kategorie entweder "Business" oder "Personal" ist. </para>
          <para>sFilter = "[Categories] = 'Personal' Or [Categories] = 'Business'" </para>
          <para>AND: Der folgende Code ruft alle persönlichen Kontakte auf, die bei Microsoft arbeiten. </para>
          <para>sFilter = "[Categories] = 'Personal' and [CompanyName] = 'Microsoft'" </para>
          <para>NOT: Der folgende Code ruft alle persönlichen Kontakte auf, die nicht bei Microsoft arbeiten. </para>
          <para>sFilter = "[Categories] = 'Personal' and Not([CompanyName] = 'Microsoft')"</para>
          <para>Zusätzliche Hinweise</para>
          <para>Wenn Sie versuchen, die Find- oder Restrict-Methoden mit benutzerdefinierten Feldern zu verwenden, müssen die Felder im Ordner definiert werden, andernfalls tritt ein Fehler auf. Es gibt keine Möglichkeit, eine "contains"-Operation auszuführen. Sie können z. B. nicht mithilfe der Methode Find oder Restrict nach Elementen suchen, die ein bestimmtes Wort im Feld Betreff enthalten. Verwenden Sie stattdessen die AdvancedSearch-Methode, oder durchlaufen Sie alle Elemente im Ordner in einer Schleife, und verwenden Sie die InStr-Funktion, um eine Suche innerhalb eines Felds auszuführen. Mithilfe der Restrict-Methode können Sie nach Elementen suchen, die innerhalb eines bestimmten Bereichs von Zeichen beginnen. Verwenden Sie z. B. den folgenden Filter, um nach allen Kontakten mit einem Nachnamen zu suchen, der mit dem Buchstaben "M" beginnt: </para>
          <para>sFilter = "[LastName] &gt; 'LZZZ' and [LastName] &lt; 'N'"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nachdem die Methode ausgeführt wurde, sucht und gibt diese Methode <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  das nächste Outlook-Element in der angegebenen Auflistung zurück.</summary>
        <returns>Ein Objektwert, der das nächste gefundene Outlook-Element in der Auflistung darstellt.</returns>
        <remarks><para> Der Suchvorgang beginnt an der aktuellen Position, die den Ausdruck festgelegte über die <b>Find</b> -Methode entspricht.</para>
          <para>Die Methode gibt ein #A0 zurück, wenn der Aufruf erfolgreich ist. Es gibt <b>Nothing</b> (ein Nullverweis (Nothing in Visual Basic) in C#) zurück, wenn ein Fehler auftritt.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das erste Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das erste in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Gibt <b>Nothing</b> zurück, wenn kein erstes Objekt vorhanden ist, z. B. wenn keine Objekte in der Auflistung vorhanden sind. Um den korrekten Betrieb der <b>Methoden GetFirst</b>, , und in einer großen Auflistung sicherzustellen, rufen Sie <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> <b>GetFirst</b> auf, bevor <b>Sie GetNext</b> für diese Auflistung aufrufen, und rufen <b>Sie GetLast</b> auf, bevor <b>Sie GetPrevious aufrufen.</b> Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das letzte Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das letzte in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Es gibt <b>Nothing zurück,</b> wenn kein letztes Objekt vorhanden ist, z. B. wenn die Auflistung leer ist. Um den korrekten Betrieb der Methoden , GetLast , und in einer großen Auflistung sicherzustellen, rufen Sie <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" /> <b></b> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> <b>GetFirst</b> auf, bevor <b>Sie GetNext</b> für diese Auflistung aufrufen, und rufen <b>Sie GetLast</b> auf, bevor <b>Sie GetPrevious aufrufen.</b> Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das nächste Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das nächste in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Es gibt <b>Nothing zurück,</b> wenn kein nächstes Objekt vorhanden ist, z. B. wenn es bereits am Ende der Auflistung positioniert ist. Um den korrekten Betrieb der Methoden , , GetNext und in einer großen Auflistung sicherzustellen, rufen Sie <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <b></b> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> <b>GetFirst</b> auf, bevor <b>Sie GetNext</b> für diese Auflistung aufrufen, und rufen <b>Sie GetLast</b> auf, bevor <b>Sie GetPrevious aufrufen.</b> Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das vorherige Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das vorherige in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Es gibt <b>Nothing zurück,</b> wenn kein vorheriges Objekt vorhanden ist, z. B. wenn es bereits am Anfang der Auflistung positioniert ist. Um den korrekten Betrieb der Methoden , , , und GetPrevious in einer großen Auflistung sicherzustellen, rufen Sie <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" /> <b>GetFirst</b> auf, bevor <b>Sie GetNext</b> <b></b> für diese Auflistung aufrufen, und rufen Sie <b>GetLast</b> auf, bevor Sie <b>GetPrevious aufrufen.</b> Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen <b>Wert vom Typ Boolean</b> (<b>bool</b> in C#) zurück, der <b>True</b> angibt, wenn die Auflistung <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> Serienmuster enthalten soll. Lese-/Schreibzugriff.</summary>
        <value>To be added.</value>
        <remarks><para>Diese Eigenschaft wirkt sich nur aus, wenn die <b>Items-Auflistung</b> Termine enthält und nicht nach einer anderen Eigenschaft als in aufsteigender <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> Reihenfolge sortiert wird. Der Standardwert ist <b>False</b>. Verwenden Sie diese Eigenschaft, wenn Sie alle Termine für ein bestimmtes Datum abrufen möchten, auf dem würde Terminserien normalerweise nicht angezeigt werden, da sie nicht mit einem bestimmten Datum verknüpft sind. Wenn Sie müssen zum Sortieren und Filtern auf Terminelemente Termine, die Terminserien enthalten, müssen Sie dazu in der angegebenen Reihenfolge: die Elemente in aufsteigender Reihenfolge sortiert, <b>IncludeRecurrences</b> auf <b>True</b> festgelegt und dann die Elemente filtern. Ein Codebeispiel mit dieser Reihenfolge finden Sie im zweite Beispiel unten. Die Auflistung Terminserien ohne Enddatum enthält, kann die Eigenschaft auf <b>True</b> festlegen die Auflistung, das unendlich viele verursachen. Achten Sie darauf, dass Sie einen Test für dieses in jeder Schleife enthalten. Sie sollten nicht <b>Count</b> -Eigenschaft der <b>Items</b> -Auflistung verwenden, wenn Sie die <b>Items</b> -Auflistung mit <b>IncludeRecurrence</b> -Eigenschaft auf <b>True</b> festgelegt. Der Wert von <b>Count</b> wird ein nicht definierter Wert sein.</para>
          <para>
            <b>Achtung:</b>Das Filtern nach einer sortierten Liste von Vorkommen hat zur Ursache, dass die IncludeRecurrences-Eigenschaft nicht wie erwartet funktioniert. Die folgende Sequenz gibt z. B. alle Terminvorkommen zurück. Serien- und Nichtserien: (1) Sortieren nach Start-Eigenschaft (2) Set-Eigenschaft auf false (3) Aufruf Restrict (d. h. Filter).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Entweder der Indexwert des Objekts oder ein Wert, der mit der Standardeigenschaft eines Objekts in der Auflistung übereinstimmt.</param>
        <summary>Ein Outlook-Element aus einer Auflistung wird zurückgegeben.</summary>
        <value>Ein Objektwert, der das angegebene Objekt darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das übergeordnete <b>Objekt</b> des angegebenen Objekts zurück. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Objekt, dieses Mitglied oder diese Aufzählung ist veraltet und kann nicht in Ihrem Code verwendet werden.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Der 1-basierte Indexwert des Objekts in der Auflistung.</param>
        <summary>Entfernt ein Objekt aus der Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die Eigenschaften, die mit der Methode zwischengespeichert <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> wurden.</summary>
        <remarks><para>Alle Eigenschaften kann weiterhin zugegriffen werden, nachdem die <b>ResetColumns</b> -Methode aufrufen. <b>SetColumns</b> sollte erneut verwendet werden, um die neue Eigenschaften zu speichern. <b>ResetColumns</b> hat keine Funktion, wenn <b>SetColumns</b> nicht vorher aufgerufen wurde.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Ein Filterausdruck, der angewendet werden soll. Weitere Informationen finden Sie in der <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  Methode.</param>
        <summary>Wendet einen Filter auf die Auflistung an und gibt eine neue Auflistung zurück, die alle Elemente aus dem Original enthält, <see cref="T:Microsoft.Office.Interop.Outlook.Items" />  die mit dem Filter übereinstimmen.</summary>
        <returns>Eine <b>Items-Auflistung,</b> die die Elemente aus der ursprünglichen <b>Items-Auflistung</b> darstellt, die mit dem Filter übereinstimmen.</returns>
        <remarks><para>Diese Methode ist eine Alternative zur Verwendung der Methode oder Methode zum <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />  Iterieren bestimmter Elemente in einer Auflistung. Die Methoden <b>Find</b> oder <b>FindNext</b> sind schneller als Filtern, wenn nur wenige Elemente vorhanden sind. Die <b>Restrict</b>-Methode ist erheblich schneller, wenn sich eine große Zahl von Elementen in der Auflistung befindet, insbesondere wenn vermutlich nur wenige Elemente in einer umfangreichen Auflistung gefunden werden.</para>
          <para>
            <b>Hinweis:</b>Wenn Sie benutzerdefinierte Felder als Teil einer <b>Find-</b> oder <b>Restrict-Klausel</b> verwenden, müssen die benutzerdefinierten Felder im Ordner vorhanden sein. Sonst generiert der Code einen Fehler, der darauf hinweist, dass das Feld nicht bekannt ist. Sie können ein Feld zu einem Ordner hinzufügen, indem Sie die  Feldauswahl anzeigen und auf Neu klicken.</para>
          <para>Diese Methode kann bei den folgenden Eigenschaften nicht verwendet werden und führt zu einem Fehler:</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Filter für die Suchen und Einschränken-Methode erstellen</para>
          <para>Die Syntax für den Filter variiert je nach dem Typ des Felds, das Sie filtern möchten.</para>
          <para>String (für Textfelder) </para>
          <para>Beim Durchsuchen von Textfeldern können Sie entweder ein Apostroph (') oder doppelte Anführungszeichen ("") verwenden, um die Werte zu trennen, die Teil des Filters sind. Beispielsweise funktionieren alle folgenden Zeilen ordnungsgemäß, wenn das Feld vom Typ <b>String</b> (<b>string</b> in C#): </para>
          <para>sFilter = "[CompanyName] = 'Microsoft'" </para>
          <para>sFilter = "[CompanyName] = ""Microsoft""" </para>
          <para>sFilter = "[CompanyName] = " &amp; Chr(34) &amp; "Microsoft" &amp; Chr(34)</para>
          <para>Wenn Sie beim Angeben eines Filters in einer Jet- oder DASL-Abfrage ein Paar einfache Anführungszeichen zum Trennen einer Zeichenfolge verwenden, die Bestandteil des Filters ist, und diese Zeichenfolge ein weiteres einfaches Anführungszeichen oder Apostroph enthält, müssen Sie ein weiteres einfaches Anführungszeichen vor dem zusätzlichen einfachen Anführungszeichen bzw. Apostroph als Escapezeichen hinzufügen. Gehen Sie ähnlich vor, wenn ein Paar doppelte Anführungszeichen zum Trennen einer Zeichenfolge verwendet wird. Enthält die Zeichenfolge bereits ein doppeltes Anführungszeichen, fügen Sie ein weiteres doppeltes Anführungszeichen als Escapezeichen vor diesem doppelten Anführungszeichen hinzu.</para>
          <para>In der DASL-Filterzeichenfolge, die nach der <b>Subject-Eigenschaft</b> filtert, die dem Wort entspricht, ist die gesamte Filterzeichenfolge beispielsweise durch ein Paar doppelter Anführungszeichen getrennt, und die eingebettete Zeichenfolge kann nicht durch ein Paar einzelner Anführungszeichen getrennt werden. Es gibt drei Zeichen, die Sie in dieser Filterzeichenfolge escapen müssen: das startende doppelte Anführungszeichen und das endende doppelte Anführungszeichen für den Eigenschaftenverweis von , und das Apostroph in der Wertbedingung für das Wort kann http://schemas.microsoft.com/mapi/proptag/0x0037001f nicht. Durch Anwendung der geeigneten Escapezeichen kann die Filterzeichenfolge wie folgt ausgedrückt werden:</para>
          <para>filter = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f "" = 'can''t'"</para>
          <para>Alternativ können Sie die chr(34)-Funktion verwenden, um das doppelte Anführungszeichen darzustellen (dessen ASCII-Zeichenwert "34" ist), das als Escapezeichen verwendet wird. Unter Verwendung der chr(34)-Ersetzung für ein doppeltes Anführungszeichen als Escapezeichen können Sie das letzte Beispiel wie folgt ausdrücken:</para>
          <para>filter = "@SQL= " &amp; Chr(34) &amp; " " http://schemas.microsoft.com/mapi/proptag/0x0037001f _</para>
          <para>    &amp; Chr(34) &amp; " = " &amp; "'can't'"</para>
          <para>Das Escapen von einfachen und doppelten Anführungszeichen ist ebenfalls in DASL-Abfragen mit den Operatoren <b>ci_startswith</b> und <b>ci_phrasematch</b> erforderlich. Folgende Abfrage führt beispielsweise eine Begriffvergleichsabfrage für can't im Nachrichtenbetreff aus: </para>
          <para>filter = "@SQL=" &amp; Chr(34) &amp; " http://schemas.microsoft.com/mapi/proptag/0x0037001E " _</para>
          <para>    &amp; Chr(34) &amp; " ci_phrasematch " &amp; "'can't'"</para>
          <para>Ein weiteres Beispiel ist eine DASL-Filterzeichenfolge, die filtert, dass die <b>Subject-Eigenschaft</b> den Wörtern entspricht, die dem richtigen Zeug entspricht, wobei das Wortzeug durch doppelte Anführungszeichen eingeschlossen wird. In diesem Fall müssen die umschließenden doppelten Anführungszeichen wie folgt escapet werden:</para>
          <para>filter = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f "" = 'the right ""stuff""'"</para>
          <para>Ein anderer Satz von Escaperegeln gilt für Eigenschaftenverweise bei benannten Eigenschaften, die ein Leerzeichen, ein einfaches oder ein doppeltes Anführungszeichen enthalten. Weitere Informationen finden Sie unter Eigenschaften nach Namespace referenzieren.</para>
          <para>Datum</para>
          <para>Obwohl Datums- und Uhrzeitangaben in der <b></b> Regel mit einem Date-Format gespeichert werden, erfordern die <b>Methoden Suchen</b> und Einschränken, dass Datum und Uhrzeit in eine Zeichenfolgendarstellung konvertiert werden. Um sicherzustellen, dass das Datum wie von Microsoft Outlook erwartet formatiert ist, verwenden Sie die Funktion <b>Format</b>. Im folgenden Beispiel wird einen Filter erstellt, um alle Kontakte zu finden, die nach dem 15. Januar 1999, 15:30 Uhr, geändert wurden </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; Format("1/15/99 15:30pm", "ddddd h:nn AMPM") &amp; "'"</para>
          <para>Boolesche Operatoren</para>
          <para>Operatoren vom Typ Boolean (TRUE/FALSE, YES/NO, ON/OFF usw.) dürfen nicht in eine Zeichenfolge konvertiert werden. Wenn Sie z. B. ermitteln möchten, ob das Journal für Kontakte aktiviert ist, können Sie den folgenden Filter verwenden:</para>
          <para>sFilter = "[Journal] = True" </para>
          <para>
            <b>Hinweis</b>: Wenn Sie Anführungszeichen als Trennzeichen mit <b>booleschen</b> Feldern verwenden, findet eine leere Zeichenfolge Elemente, deren Felder <b>False</b> sind, und alle nicht leeren Zeichenfolgen finden Elemente, deren Felder <b>True sind.</b> </para>
          <para>Keywords (oder Categories)</para>
          <para>Das Feld Categories ist von Typschlüsselwörtern, die mehrere Werte enthalten sollen. When accessing it programmatically, the Categories field behaves like a Text field, and the string must match exactly. Values in the text string are separated by a comma and a space. This typically means that you cannot use the <b>Find</b> and <b>Restrict</b> methods on a keywords field if it contains more than one value. For example, if you have one contact in the Business category and one contact in the Business and Social categories, you cannot easily use the <b>Find</b> and <b>Restrict</b> methods to retrieve all items that are in the Business category. Instead, you can loop through all contacts in the folder and use the <b>Instr</b> function to test whether the string "Business" is contained within the entire keywords field. </para>
          <para>
            <b>Hinweis</b>: Eine mögliche Ausnahme ist, wenn Sie das Feld Kategorien auf zwei oder eine niedrige Anzahl von Werten beschränken. Anschließend können Sie die <b>Methoden Find</b> und <b>Restrict</b> mit dem logischen Operator OR verwenden, um alle Geschäftskontakte abzurufen. Zum Beispiel (im Pseudocode): "Unternehmen" oder "Unternehmen, persönlich" oder "Persönlich, Unternehmen" Bei Kategoriezeichenfolgen wird nicht zwischen Groß- und Kleinschreibung unterschieden. </para>
          <para>Ganze Zahl</para>
          <para>Das Durchsuchen von Feldern vom Typ <b>Integer</b> ist sowohl mit als auch ohne Anführungszeichen und Trennzeichen möglich. Mithilfe folgender Filter wird nach Kontakten gesucht, die in Outlook 2000 erstellt wurden: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = '92711'"</para>
          <para>Verwenden von Variablen in Filtern</para>
          <para>Wie das Beispiel mit der <b>Restrict</b>-Methode zeigt, können Werte aus Variablen als Teil des Filters verwendet werden. Im folgenden Microsoft Visual Basic Codebeispiel wird die Syntax veranschaulicht, die Variablen als Teil des Filters verwendet. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para>' Dieser Ansatz verwendet Chr(34), um den Wert zu trennen. </para>
          <para>sFilter = "[FullName] = " &amp; Chr(34) &amp; sFullName &amp; Chr(34) </para>
          <para>' Bei diesem Ansatz werden doppelte Anführungszeichen verwendet, um den Wert zu trennen. </para>
          <para>sFilter = "[FullName] = """ &amp; sFullName &amp; """"</para>
          <para>Verwenden von logischen Operatoren als Teil des Filters</para>
          <para>Logische Operatoren, die zulässig sind, sind UND, ODER und NICHT. Im Folgenden finden Sie Variationen der Klausel für die <b>Restrict-Methode,</b> sodass Sie mehrere Kriterien angeben können.  </para>
          <para>OR: Der folgende Code gibt alle Kontaktelemente zurück, deren Kategorie entweder "Business" oder "Personal" ist. </para>
          <para>sFilter = "[Categories] = 'Personal' Or [Categories] = 'Business'" </para>
          <para>AND: Der folgende Code ruft alle persönlichen Kontakte auf, die bei Microsoft arbeiten. </para>
          <para>sFilter = "[Categories] = 'Personal' and [CompanyName] = 'Microsoft'" </para>
          <para>NOT: Der folgende Code ruft alle persönlichen Kontakte auf, die nicht bei Microsoft arbeiten. </para>
          <para>sFilter = "[Categories] = 'Personal' and Not([CompanyName] = 'Microsoft')"</para>
          <para>Zusätzliche Hinweise</para>
          <para>Wenn Sie die <b>Find</b>- oder <b>Restrict</b>-Methode in benutzerdefinierten Feldern verwenden möchten, müssen die Felder im Ordner definiert sein, da andernfalls ein Fehler auftritt. Es gibt keine Möglichkeit, eine "contains"-Operation auszuführen. Sie können z. B. nicht mithilfe der Methode <b>Find</b> oder <b>Restrict</b> nach Elementen suchen, die ein bestimmtes Wort im Feld Betreff enthalten. Stattdessen können Sie die -Methode verwenden, oder Sie können alle Elemente im Ordner durchschleifen und die InStr-Funktion verwenden, um eine Suche innerhalb eines <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> Felds durchzuführen. <b></b> Mithilfe der <b>Restrict</b>-Methode können Sie nach Elementen suchen, die innerhalb eines bestimmten Bereichs von Zeichen beginnen. Verwenden Sie z. B. den folgenden Filter, um nach allen Kontakten mit einem Nachnamen zu suchen, der mit dem Buchstaben "M" beginnt: </para>
          <para>sFilter = "[LastName] &gt; 'LZZZ' and [LastName] &lt; 'N'"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" />  Objekt für die aktuelle Sitzung zurück. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks><para>Die <b>Session-Eigenschaft</b> und die -Methode können austauschbar verwendet werden, um das <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> <b>NameSpace-Objekt für</b> die aktuelle Sitzung zu erhalten. Beide Member haben denselben Zweck. Die folgenden Anweisungenpaare führen beispielsweise dieselbe Funktion aus:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">Eine Zeichenfolge, die die Namen der zwischenzuspeichernden Eigenschaften enthält. Die Eigenschaftsnamen werden in dieser Zeichenfolge durch Kommas getrennt.</param>
        <summary>Bestimmte Eigenschaften werden für den sehr schnellen Zugriff auf die jeweiligen Eigenschaften eines Elements innerhalb der Auflistung zwischengespeichert.</summary>
        <remarks><para>Die <b>SetColumns-Methode</b> ist nützlich, um die Auflistung zu <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> durch iterieren. Wenn Sie diese Methode nicht verwenden, müssen Microsoft Outlook jedes Element zum Zugriff auf die Eigenschaft öffnen. Mit der <b>SetColumns</b> -Methode überprüft Outlook nur die Eigenschaften, die Sie zwischengespeichert wurden, und ermöglicht den schnellen, schreibgeschützten Zugriff auf diese Eigenschaften.</para>
          <para>Nachdem Sie die <b>SetColumns-Methode</b> auf bestimmte Eigenschaften der Auflistung angewendet haben, können Sie keine anderen Eigenschaften dieser Auflistung lesen. Eigenschaften, die nicht zwischengespeichert werden, werden leer zurückgegeben. Sie können auch keines der Eigenschaften dieser Auflistung schreiben. Wenn Sie Lese-/Schreibzugriff benötigen, können Sie auch schnell auf eine Gruppe von Elementen zugreifen. <see cref="T:Microsoft.Office.Interop.Outlook.Table" /></para>
          <para>
            <b>SetColumns</b> kann nicht verwendet werden und verursacht einen Fehler, jede Eigenschaft, die ein Objekt zurückgibt. Es kann nicht mit den folgenden Eigenschaften verwendet werden:</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Text</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Kategorien</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Klasse</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Unternehmen</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Gespeichert</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Gesendet</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Übermittelt</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para><b>ConversationIndex</b> -Eigenschaft kann nicht mit der <b>SetColumns</b> -Methode zwischengespeichert werden sollen. Diese Eigenschaft führt jedoch nicht zu einem Fehler wie die oben aufgelisteten Eigenschaften.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">Der Name der Eigenschaft, anhand der sortiert werden soll; dieser kann in Klammer eingeschlossen sein, z. B. "[CompanyName]". Benutzerdefinierte Eigenschaften, die Leerzeichen enthalten, müssen in Klammern eingeschlossen werden. Darf keine benutzerdefinierte Eigenschaft von type-Schlüsselwörtern und keine mehrwertige Eigenschaft, z. B. „category“, sein. Für benutzerdefinierte Eigenschaften muss die Eigenschaft in der <b>UserDefinedProperties-Auflistung</b> für vorhanden sein, die das Objekt darstellt, <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" /> das die Elemente <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> enthält.</param>
        <param name="Descending"><b>True,</b> um in absteigender Reihenfolge zu sortieren. Der Standardwert ist <b>False</b> (aufsteigend).</param>
        <summary>Sorts the collection of items by the specified property. The index for the collection is reset to 1 upon completion of this method.</summary>
        <remarks><para>
            <b>Sort</b> wirkt sich lediglich auf die Reihenfolge der Elemente in einer Auflistung. Es wirkt sich nicht auf die Reihenfolge von Elementen in einem Explorer-Ansicht.</para>
          <para>
            <b>Sort</b> kann nicht verwendet werden und verursacht einen Fehler, wenn <paramref name="property" /> der Parameter eine der folgenden Eigenschaften ist:                </para>
          <list type="table">
            <item>
              <description>
                <b>Kategorien</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Klasse</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Gespeichert</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Gesendet</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
