<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90ccbcb3fe07f548327e1919c5fa54fecbde32ba" /><Meta Name="ms.sourcegitcommit" Value="8bffa304e2953ca61fa94459dd08997552262640" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/05/2019" /><Meta Name="ms.locfileid" Value="31479562" /></Metadata><TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hierbei handelt es sich um eine primäre Schnittstelle in einer COM-CoClass, die von verwaltetem Code benötigt wird, um Interoperabilität mit dem entsprechenden COM-Objekt sicherzustellen. Verwenden Sie diese primäre Schnittstelle nur, wenn die Methode, die Sie verwenden möchten, den gleichen Namen aufweist wie ein Ereignis des COM-Objekts; casten Sie in diesem Fall zu dieser Schnittstelle, um die Methode aufzurufen, und casten Sie zur aktuellen Ereignisschnittstelle, um eine Verbindung zum Ereignis herzustellen. Verwenden Sie andernfalls die von der COM-CoClass abgeleitete .NET-Schnittstelle, um auf Methoden, Eigenschaften und Ereignisse des COM-Objekts zuzugreifen. Informationen zum COM-Objekt finden Sie unter <see cref="T:Microsoft.Office.Interop.Outlook.Items" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">Outlook-Elementtyp für das neue Element. Gibt eine <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> zum Erstellen benutzerdefinierter Formulare an. Kann eine der folgenden <b>OlItemType</b> -Konstanten sein: <b>OlAppointmentItem</b>, <b>OlContactItem</b>, <b>OlJournalItem</b>, <b>OlMailItem</b>, <b>OlNoteItem</b>, <b>OlPostItem</b> oder <b>OlTaskItem,</b> oder eine beliebige gültige Nachrichtenklasse.</param>
        <summary>Erstellt ein neues Outlook-Element in <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> der Auflistung für den Ordner.</summary>
        <returns>Ein Objektwert, der das neue Outlook-Element darstellt.</returns>
        <remarks><para>Wenn nicht angegeben, ist die <b>Type</b> -Eigenschaft des Outlook-Elements standardmäßig auf den Typ des Ordners <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /> oder auf, wenn der übergeordnete Ordner nicht eingegeben wird.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt ein <see cref="T:Microsoft.Office.Interop.Outlook.Application" /> Object zurück, das die übergeordnete Outlook-Anwendung für das Objekt darstellt. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> Konstante zurück, die die Klasse des Objekts angibt. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen <b>Integer</b> (<b>int</b> in C#)-Wert zurück, der die Anzahl der Objekte in der angegebenen Auflistung angibt. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Eine Zeichenfolge, die die Kriterien angibt, die das zurückgegebene Objekt erfüllen muss.</param>
        <summary>Sucht und gibt ein Outlook-Element Objekt zurück, das dem angegebenen <paramref name="Filter" />entspricht.</summary>
        <returns>Ein Object-Wert, der ein Outlook-Element darstellt, wenn der Aufruf erfolgreich ist; gibt <b>Nothing</b> (NULL-Verweis (Nothing in Visual Basic) in C#) zurück, wenn ein Fehler auftritt.</returns>
        <remarks><para>Verwenden Sie die <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> -Methode, um <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> die Inhalts Indizierungs Suche in der Auflistung zu verwenden. <b>FindRow</b> gibt einen Fehler zurück, <paramref name="Filter" /> Wenn Inhalts Indizierungs Schlüsselwörter enthalten. Weitere Informationen zu Inhalts Indizierungs Schlüsselwörtern finden Sie unter <a href="http://go.microsoft.com/fwlink/?LinkId=87947">Filtern von Elementen mithilfe von Abfrageschlüsselwörtern</a></para>
          <para>Die-Methode gibt einen Fehler mit den folgenden Eigenschaften in der <paramref name="Filter" />zurück: </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Filter für die Suchen und Einschränken-Methode erstellen</para>
          <para>Die Syntax für den Filter variiert je nach dem Typ des Felds, das Sie filtern möchten.</para>
          <para>String (für Textfelder) </para>
          <para>Beim Durchsuchen von Text Feldern können Sie entweder ein Apostroph (') oder doppelte Anführungszeichen ("") verwenden, um die Werte zu begrenzen, die Teil des Filters sind. Beispielsweise funktionieren alle der folgenden Zeilen ordnungsgemäß, wenn das Feld vom Typ <b>String</b> (<b>Zeichenfolge</b> in C#) ist: </para>
          <para>sFilter = "[CompanyName] = ' Microsoft '" </para>
          <para>sFilter = "[CompanyName] =" "Microsoft" "" </para>
          <para>sFilter = "[CompanyName] =" &amp; Chr (34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>Wenn Sie beim Angeben eines Filters in einer Jet- oder DASL-Abfrage ein Paar einfache Anführungszeichen zum Trennen einer Zeichenfolge verwenden, die Bestandteil des Filters ist, und diese Zeichenfolge ein weiteres einfaches Anführungszeichen oder Apostroph enthält, müssen Sie ein weiteres einfaches Anführungszeichen vor dem zusätzlichen einfachen Anführungszeichen bzw. Apostroph als Escapezeichen hinzufügen. Gehen Sie ähnlich vor, wenn ein Paar doppelte Anführungszeichen zum Trennen einer Zeichenfolge verwendet wird. Enthält die Zeichenfolge bereits ein doppeltes Anführungszeichen, fügen Sie ein weiteres doppeltes Anführungszeichen als Escapezeichen vor diesem doppelten Anführungszeichen hinzu.</para>
          <para>In der DASL-Filterzeichenfolge, die filtert, dass die <b>Subject</b> -Eigenschaft gleich dem Wort "nicht" ist, wird die gesamte Filterzeichenfolge durch ein paar doppelter Anführungszeichen getrennt, und die eingebettete Zeichenfolge kann nicht durch ein paar von einfachen Anführungszeichen voneinander getrennt werden. Es gibt drei Zeichen, die Sie in dieser Filterzeichenfolge entfliehen müssen: die beginnende doppelte Anführungszeichen und die enddoppelte Anführungsstrich für den Eigenschaftenverweis von http://schemas.microsoft.com/mapi/proptag/0x0037001f, und das Apostroph in der Wert Bedingung für das Wort kann nicht. Durch Anwendung der geeigneten Escapezeichen kann die Filterzeichenfolge wie folgt ausgedrückt werden:</para>
          <para>Filter = "@SQL="http://schemas.microsoft.com/mapi/proptag/0x0037001f"" "" = ' kann ' 't ' "</para>
          <para>Alternativ können Sie die chr(34)-Funktion verwenden, um das doppelte Anführungszeichen darzustellen (dessen ASCII-Zeichenwert "34" ist), das als Escapezeichen verwendet wird. Unter Verwendung der chr(34)-Ersetzung für ein doppeltes Anführungszeichen als Escapezeichen können Sie das letzte Beispiel wie folgt ausdrücken:</para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp;Chr (34) &amp; "=" &amp; "' kann ' 't '"</para>
          <para>Das Escapen von einfachen und doppelten Anführungszeichen ist ebenfalls in DASL-Abfragen mit den Operatoren <b>ci_startswith</b> und <b>ci_phrasematch</b> erforderlich. Folgende Abfrage führt beispielsweise eine Begriffvergleichsabfrage für can't im Nachrichtenbetreff aus: </para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp;Chr (34) &amp; "ci_phrasematch" &amp; "" kann ' t ' "</para>
          <para>Ein weiteres Beispiel ist eine DASL-Filterzeichenfolge, die filtert, dass die <b>Subject</b> -Eigenschaft den Wörtern das richtige entspricht, wobei das Wort stuff mit doppelten Anführungszeichen eingeschlossen ist. In diesem Fall müssen die umschließenden doppelten Anführungszeichen wie folgt escapet werden:</para>
          <para>Filter = "@SQL="http://schemas.microsoft.com/mapi/proptag/0x0037001f"" "= ' der richtige" "stuff" "'"</para>
          <para>Ein anderer Satz von Escaperegeln gilt für Eigenschaftenverweise bei benannten Eigenschaften, die ein Leerzeichen, ein einfaches oder ein doppeltes Anführungszeichen enthalten. Weitere Informationen finden Sie unter Eigenschaften nach Namespace referenzieren.</para>
          <para>Datum</para>
          <para>Obwohl Datums-und Uhrzeitangaben in der Regel mit einem Datumsformat gespeichert werden, erfordern die Methoden Find und Restrict, dass das Datum und die Uhrzeit in eine Zeichenfolgendarstellung konvertiert werden. Um sicherzustellen, dass das Datum wie von Microsoft Outlook erwartet formatiert ist, verwenden Sie die Funktion Format. The following example creates a filter to find all contacts that have been modified after January 15, 1999 at 3:30 P.M. </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; Format ("1/15/99 3:19:30", "ddddd h:NN ampm") &amp; "'"</para>
          <para>Boolesche Operatoren</para>
          <para>Operatoren vom Typ Boolean (TRUE/FALSE, YES/NO, ON/OFF usw.) dürfen nicht in eine Zeichenfolge konvertiert werden. Wenn Sie z. B. ermitteln möchten, ob das Journal für Kontakte aktiviert ist, können Sie den folgenden Filter verwenden:</para>
          <para>sFilter = "[Journal] = true" </para>
          <para>
            <b>Hinweis</b>: Wenn Sie Anführungszeichen als Trennzeichen mit booleschen Feldern verwenden, finden Sie in einer leeren Zeichenfolge Elemente, deren Felder false sind, und alle nicht leeren Zeichenfolgensuchen nach Elementen, deren Felder den Wert true haben.</para>
          <para>Keywords (oder Categories)</para>
          <para>Das Feld Kategorien ist vom Typ Schlüsselwörter, die für mehrere Werte vorgesehen ist. When accessing it programmatically, the Categories field behaves like a Text field, and the string must match exactly. Values in the text string are separated by a comma and a space. This typically means that you cannot use the Find and Restrict methods on a keywords field if it contains more than one value. For example, if you have one contact in the Business category and one contact in the Business and Social categories, you cannot easily use the Find and Restrict methods to retrieve all items that are in the Business category. Instead, you can loop through all contacts in the folder and use the Instr function to test whether the string "Business" is contained within the entire keywords field. </para>
          <para>
            <b>Hinweis</b>: eine mögliche Ausnahme ist, wenn Sie das Feld Kategorien auf zwei oder eine niedrige Anzahl von Werten begrenzen. Dann können Sie die Methoden Find und Restrict mit dem logischen Operator oder verwenden, um alle Geschäftskontakte abzurufen. Zum Beispiel (im Pseudocode): "Unternehmen" oder "Unternehmen, persönlich" oder "Persönlich, Unternehmen" Bei Kategoriezeichenfolgen wird nicht zwischen Groß- und Kleinschreibung unterschieden.</para>
          <para>Ganze Zahl</para>
          <para>Das Durchsuchen von Feldern vom Typ Integer ist sowohl mit als auch ohne Anführungszeichen und Trennzeichen möglich. Mithilfe folgender Filter wird nach Kontakten gesucht, die in Outlook 2000 erstellt wurden: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = ' 92711 '"</para>
          <para>Verwenden von Variablen in Filtern</para>
          <para>Wie im Beispiel der Restrict-Methode veranschaulicht, können Sie Werte aus Variablen als Teil des Filters verwenden. Das folgende Microsoft Visual Basic-Codebeispiel veranschaulicht die Syntax, die Variablen als Teil des Filters verwendet. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para> Dieser Ansatz verwendet Chr (34), um den Wert abzugrenzen: sFilter = "[FullName] &amp; =" Chr ( &amp; 34 &amp; ) sFullName Chr (34) </para>
          <para> Bei diesem Ansatz werden doppelte Anführungszeichen verwendet, um den Wert zu begrenzen: sFilter = "[ &amp; FullName &amp; ] =" "" sFullName "" ""</para>
          <para>Verwenden von logischen Operatoren als Teil des Filters</para>
          <para>Logische Operatoren, die zulässig sind, sind UND, ODER und NICHT. Es folgen Variationen der Klausel für die Restrict-Methode, sodass Sie mehrere Kriterien angeben können.  </para>
          <para>OR: Der folgende Code gibt alle Kontaktelemente zurück, deren Kategorie entweder "Business" oder "Personal" ist. </para>
          <para>sFilter = "[categories] = ' Personal ' oder [categories] = ' Business '" </para>
          <para>AND: Der folgende Code ruft alle persönlichen Kontakte auf, die bei Microsoft arbeiten. </para>
          <para>sFilter = "[categories] = ' Personal ' und [CompanyName] = ' Microsoft '" </para>
          <para>NOT: Der folgende Code ruft alle persönlichen Kontakte auf, die nicht bei Microsoft arbeiten. </para>
          <para>sFilter = "[categories] = ' Personal" und nicht ([CompanyName] = ' Microsoft ') "</para>
          <para>Zusätzliche Hinweise</para>
          <para>Wenn Sie versuchen, die Methoden Find oder Restrict mit benutzerdefinierten Feldern zu verwenden, müssen die Felder im Ordner definiert werden, andernfalls tritt ein Fehler auf. Es gibt keine Möglichkeit, eine "contains"-Operation auszuführen. Sie können z. B. nicht mithilfe der Methode Find oder Restrict nach Elementen suchen, die ein bestimmtes Wort im Feld Betreff enthalten. Verwenden Sie stattdessen die AdvancedSearch-Methode, oder durchlaufen Sie alle Elemente im Ordner in einer Schleife, und verwenden Sie die InStr-Funktion, um eine Suche innerhalb eines Felds auszuführen. Mithilfe der Restrict-Methode können Sie nach Elementen suchen, die innerhalb eines bestimmten Bereichs von Zeichen beginnen. Verwenden Sie z. B. den folgenden Filter, um nach allen Kontakten mit einem Nachnamen zu suchen, der mit dem Buchstaben "M" beginnt: </para>
          <para>sFilter = "[LastName] &gt; ' LZZZ ' und [LastName] &lt; ' N '"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nachdem die <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> Methode ausgeführt wurde, findet und gibt diese Methode das nächste Outlook-Element in der angegebenen Auflistung zurück.</summary>
        <returns>Ein Objektwert, der das nächste gefundene Outlook-Element in der Auflistung darstellt.</returns>
        <remarks><para> Der Suchvorgang beginnt an der aktuellen Position, die den Ausdruck festgelegte über die <b>Find</b> -Methode entspricht.</para>
          <para>Die-Methode gibt ein Outlook-Element Objekt zurück, wenn der Aufruf erfolgreich ist; Wenn ein Fehler auftritt, wird <b>Nothing</b> (NULL-Verweis (Nothing in Visual Basic) in C# zurückgegeben).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das erste Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das erste in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Gibt <b>Nothing</b> zurück, wenn kein erstes Objekt vorhanden ist, zum Beispiel, wenn es keine Objekte in der Auflistung gibt. Um die ordnungsgemäße <b></b>Funktion der GetFirst- <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> ,-und-Methoden in einer umfangreichen Auflistung sicherzustellen, rufen Sie GetFirst auf, bevor Sie GetNext für diese Auflistung aufrufen und GetLast vor dem Aufruf von GetPrevious aufrufen. <b></b> <b></b> <b></b> <b> </b>. Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das letzte Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das letzte in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Wenn kein letztes Objekt vorhanden ist, beispielsweise wenn die Auflistung leer ist, wird <b>Nothing</b> zurückgegeben. <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />Um die ordnungsgemäße Funktion <b></b>der, GetLast, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />und <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> Methoden in einer umfangreichen Auflistung sicherzustellen, rufen Sie GetFirst vor dem Aufruf von GetNext für diese Auflistung auf, und rufen Sie GetLast vor dem Aufruf von GetPrevious auf. <b></b> <b></b> <b></b> <b> </b>. Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das nächste Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das nächste in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Wenn beispielsweise bereits am Ende der Auflistung positioniert ist, wird <b>Nothing</b> zurückgegeben, wenn kein nächstes Objekt vorhanden ist. Um die <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />ordnungsgemäße Funktion <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />von,, GetNext <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> und Methoden in einer umfangreichen Auflistung sicherzustellen, rufen Sie GetFirst vor dem Aufruf von GetNext für diese Auflistung auf, und rufen Sie GetLast vor dem Aufruf von GetPrevious auf. <b></b> <b></b> <b></b> <b></b> <b> </b>. Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das vorherige Objekt in der Auflistung wird zurückgegeben.</summary>
        <returns>Ein Objektwert, der das vorherige in der Auflistung enthaltene Objekt darstellt.</returns>
        <remarks><para>Wenn beispielsweise bereits am Anfang der Auflistung positioniert ist, wird <b>Nothing</b> zurückgegeben, wenn kein vorheriges Objekt vorhanden ist. Um <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />die ordnungsgemäße Funktion <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />der <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />,, und GetPrevious Methoden in einer umfangreichen Auflistung sicherzustellen, rufen Sie GetFirst, bevor Sie GetNext für diese Auflistung aufrufen, und rufen Sie GetLast vor dem Aufruf <b></b> <b></b> <b></b> <b></b> <b> GetPrevious</b>. Um sicherzustellen, dass Sie die Aufrufe immer auf die gleiche Auflistung ausführen, erstellen Sie eine explizite Variable, die auf diese vor dem Durchführen einer Schleife.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen <b>booleschen Wert</b> (<b>bool</b> in C#) zurück, der <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> <b>true</b> angibt, wenn die Auflistung Serienmuster enthalten soll. Lese-/Schreibzugriff.</summary>
        <value>To be added.</value>
        <remarks><para>Diese Eigenschaft hat nur dann eine Auswirkung, wenn die <b>Items</b> -Auflistung Termine enthält und nicht nach einer anderen Eigenschaft <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> als in aufsteigender Reihenfolge sortiert wird. Der Standardwert ist <b>False</b>. Verwenden Sie diese Eigenschaft, wenn Sie alle Termine für ein bestimmtes Datum abrufen möchten, auf dem würde Terminserien normalerweise nicht angezeigt werden, da sie nicht mit einem bestimmten Datum verknüpft sind. Wenn Sie müssen zum Sortieren und Filtern auf Terminelemente Termine, die Terminserien enthalten, müssen Sie dazu in der angegebenen Reihenfolge: die Elemente in aufsteigender Reihenfolge sortiert, <b>IncludeRecurrences</b> auf <b>True</b> festgelegt und dann die Elemente filtern. Ein Codebeispiel mit dieser Reihenfolge finden Sie im zweite Beispiel unten. Die Auflistung Terminserien ohne Enddatum enthält, kann die Eigenschaft auf <b>True</b> festlegen die Auflistung, das unendlich viele verursachen. Achten Sie darauf, dass Sie einen Test für dieses in jeder Schleife enthalten. Sie sollten nicht <b>Count</b> -Eigenschaft der <b>Items</b> -Auflistung verwenden, wenn Sie die <b>Items</b> -Auflistung mit <b>IncludeRecurrence</b> -Eigenschaft auf <b>True</b> festgelegt. Der Wert von <b>Count</b> wird ein nicht definierter Wert sein.</para>
          <para>
            <b>Achtung</b>: das Filtern nach einer sortierten Liste von Vorkommen bewirkt, dass die IncludeRecurrences-Eigenschaft nicht wie erwartet funktioniert. Die folgende Sequenz gibt beispielsweise alle Termin Vorkommen zurück; wiederkehrende und nicht wiederkehrende Aufgaben: (1) Sortieren nach Start Eigenschaft (2) Set-Eigenschaft auf false (3) Call Restrict (d. h. Filter).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Entweder der Indexwert des Objekts oder ein Wert, der mit der Standardeigenschaft eines Objekts in der Auflistung übereinstimmt.</param>
        <summary>Ein Outlook-Element aus einer Auflistung wird zurückgegeben.</summary>
        <value>Ein Objektwert, der das angegebene Objekt darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das übergeordnete <b>Objekt</b> des angegebenen Objekts zurück. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Objekt, dieses Mitglied oder diese Aufzählung ist veraltet und kann nicht in Ihrem Code verwendet werden.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Der 1-basierte Indexwert des Objekts in der Auflistung.</param>
        <summary>Entfernt ein Objekt aus der Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Eigenschaften, die mit der <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> -Methode zwischengespeichert wurden.</summary>
        <remarks><para>Alle Eigenschaften kann weiterhin zugegriffen werden, nachdem die <b>ResetColumns</b> -Methode aufrufen. <b>SetColumns</b> sollte erneut verwendet werden, um die neue Eigenschaften zu speichern. <b>ResetColumns</b> hat keine Funktion, wenn <b>SetColumns</b> nicht vorher aufgerufen wurde.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Ein Filterausdruck, der angewendet werden soll. Weitere Informationen finden Sie unter <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> der-Methode.</param>
        <summary>Wendet einen Filter auf die <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> Auflistung an und gibt eine neue Auflistung zurück, die alle Elemente aus dem Original enthält, die dem Filter entsprechen.</summary>
        <returns>Eine <b>Items</b> -Auflistung, die die Elemente aus der ursprünglichen <b>Items</b> -Auflistung darstellt, die dem Filter entsprechen.</returns>
        <remarks><para>Diese Methode ist eine Alternative zur Verwendung der <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> Methode oder <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" /> Methode zum Durchlaufen bestimmter Elemente in einer Auflistung. Die Methoden <b>Find</b> oder <b>FindNext</b> sind schneller als Filtern, wenn nur wenige Elemente vorhanden sind. Die <b>Restrict</b>-Methode ist erheblich schneller, wenn sich eine große Zahl von Elementen in der Auflistung befindet, insbesondere wenn vermutlich nur wenige Elemente in einer umfangreichen Auflistung gefunden werden.</para>
          <para>
            <b>Hinweis</b>: Wenn Sie benutzerdefinierte Felder als Teil einer <b>Find</b> -oder <b>Restrict</b> -Klausel verwenden, müssen die benutzerdefinierten Felder im Ordner vorhanden sein. Sonst generiert der Code einen Fehler, der darauf hinweist, dass das Feld nicht bekannt ist. Sie können ein Feld zu einem Ordner hinzufügen, indem Sie die  Feldauswahl anzeigen und auf Neu klicken.</para>
          <para>Diese Methode kann bei den folgenden Eigenschaften nicht verwendet werden und führt zu einem Fehler:</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Filter für die Suchen und Einschränken-Methode erstellen</para>
          <para>Die Syntax für den Filter variiert je nach dem Typ des Felds, das Sie filtern möchten.</para>
          <para>String (für Textfelder) </para>
          <para>Beim Durchsuchen von Text Feldern können Sie entweder ein Apostroph (') oder doppelte Anführungszeichen ("") verwenden, um die Werte zu begrenzen, die Teil des Filters sind. Beispielsweise funktionieren alle der folgenden Zeilen ordnungsgemäß, wenn das Feld vom Typ <b>String</b> (<b>Zeichenfolge</b> in C#) ist: </para>
          <para>sFilter = "[CompanyName] = ' Microsoft '" </para>
          <para>sFilter = "[CompanyName] =" "Microsoft" "" </para>
          <para>sFilter = "[CompanyName] =" &amp; Chr (34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>Wenn Sie beim Angeben eines Filters in einer Jet- oder DASL-Abfrage ein Paar einfache Anführungszeichen zum Trennen einer Zeichenfolge verwenden, die Bestandteil des Filters ist, und diese Zeichenfolge ein weiteres einfaches Anführungszeichen oder Apostroph enthält, müssen Sie ein weiteres einfaches Anführungszeichen vor dem zusätzlichen einfachen Anführungszeichen bzw. Apostroph als Escapezeichen hinzufügen. Gehen Sie ähnlich vor, wenn ein Paar doppelte Anführungszeichen zum Trennen einer Zeichenfolge verwendet wird. Enthält die Zeichenfolge bereits ein doppeltes Anführungszeichen, fügen Sie ein weiteres doppeltes Anführungszeichen als Escapezeichen vor diesem doppelten Anführungszeichen hinzu.</para>
          <para>In der DASL-Filterzeichenfolge, die filtert, dass die <b>Subject</b> -Eigenschaft gleich dem Wort "nicht" ist, wird die gesamte Filterzeichenfolge durch ein paar doppelter Anführungszeichen getrennt, und die eingebettete Zeichenfolge kann nicht durch ein paar von einfachen Anführungszeichen voneinander getrennt werden. Es gibt drei Zeichen, die Sie in dieser Filterzeichenfolge entfliehen müssen: die beginnende doppelte Anführungszeichen und die enddoppelte Anführungsstrich für den Eigenschaftenverweis von http://schemas.microsoft.com/mapi/proptag/0x0037001f, und das Apostroph in der Wert Bedingung für das Wort kann nicht. Durch Anwendung der geeigneten Escapezeichen kann die Filterzeichenfolge wie folgt ausgedrückt werden:</para>
          <para>Filter = "@SQL="http://schemas.microsoft.com/mapi/proptag/0x0037001f"" "" = ' kann ' 't ' "</para>
          <para>Alternativ können Sie die chr(34)-Funktion verwenden, um das doppelte Anführungszeichen darzustellen (dessen ASCII-Zeichenwert "34" ist), das als Escapezeichen verwendet wird. Unter Verwendung der chr(34)-Ersetzung für ein doppeltes Anführungszeichen als Escapezeichen können Sie das letzte Beispiel wie folgt ausdrücken:</para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp;Chr (34) &amp; "=" &amp; "' kann ' 't '"</para>
          <para>Das Escapen von einfachen und doppelten Anführungszeichen ist ebenfalls in DASL-Abfragen mit den Operatoren <b>ci_startswith</b> und <b>ci_phrasematch</b> erforderlich. Folgende Abfrage führt beispielsweise eine Begriffvergleichsabfrage für can't im Nachrichtenbetreff aus: </para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp;Chr (34) &amp; "ci_phrasematch" &amp; "" kann ' t ' "</para>
          <para>Ein weiteres Beispiel ist eine DASL-Filterzeichenfolge, die filtert, dass die <b>Subject</b> -Eigenschaft den Wörtern das richtige entspricht, wobei das Wort stuff mit doppelten Anführungszeichen eingeschlossen ist. In diesem Fall müssen die umschließenden doppelten Anführungszeichen wie folgt escapet werden:</para>
          <para>Filter = "@SQL="http://schemas.microsoft.com/mapi/proptag/0x0037001f"" "= ' der richtige" "stuff" "'"</para>
          <para>Ein anderer Satz von Escaperegeln gilt für Eigenschaftenverweise bei benannten Eigenschaften, die ein Leerzeichen, ein einfaches oder ein doppeltes Anführungszeichen enthalten. Weitere Informationen finden Sie unter Eigenschaften nach Namespace referenzieren.</para>
          <para>Datum</para>
          <para>Obwohl Datums-und Uhrzeitangaben in der Regel mit einem Datumsformat gespeichert werden, erfordern die Methoden <b>Find</b> und <b>Restrict</b> , dass das Datum und die Uhrzeit in eine Zeichenfolgendarstellung konvertiert werden. Um sicherzustellen, dass das Datum wie von Microsoft Outlook erwartet formatiert ist, verwenden Sie die Funktion <b>Format</b>. Im folgenden Beispiel wird einen Filter erstellt, um alle Kontakte zu finden, die nach dem 15. Januar 1999, 15:30 Uhr, geändert wurden </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; Format ("1/15/99 3:19:30", "ddddd h:NN ampm") &amp; "'"</para>
          <para>Boolesche Operatoren</para>
          <para>Operatoren vom Typ Boolean (TRUE/FALSE, YES/NO, ON/OFF usw.) dürfen nicht in eine Zeichenfolge konvertiert werden. Wenn Sie z. B. ermitteln möchten, ob das Journal für Kontakte aktiviert ist, können Sie den folgenden Filter verwenden:</para>
          <para>sFilter = "[Journal] = true" </para>
          <para>
            <b>Hinweis</b>: Wenn Sie Anführungszeichen als Trennzeichen mit booleschen Feldern verwenden, finden Sie in einer leeren Zeichenfolge Elemente, deren Felder <b>false</b> sind, und alle nicht leeren Zeichenfolgensuchen nach Elementen, deren Felder den <b>Wert</b> <b>true</b>haben. </para>
          <para>Keywords (oder Categories)</para>
          <para>Das Feld Kategorien ist vom Typ Schlüsselwörter, die für mehrere Werte vorgesehen ist. When accessing it programmatically, the Categories field behaves like a Text field, and the string must match exactly. Values in the text string are separated by a comma and a space. This typically means that you cannot use the <b>Find</b> and <b>Restrict</b> methods on a keywords field if it contains more than one value. For example, if you have one contact in the Business category and one contact in the Business and Social categories, you cannot easily use the <b>Find</b> and <b>Restrict</b> methods to retrieve all items that are in the Business category. Instead, you can loop through all contacts in the folder and use the <b>Instr</b> function to test whether the string "Business" is contained within the entire keywords field. </para>
          <para>
            <b>Hinweis</b>: eine mögliche Ausnahme ist, wenn Sie das Feld Kategorien auf zwei oder eine niedrige Anzahl von Werten begrenzen. Dann können Sie die Methoden <b>Find</b> und <b>Restrict</b> mit dem logischen Operator oder verwenden, um alle Geschäftskontakte abzurufen. Zum Beispiel (im Pseudocode): "Unternehmen" oder "Unternehmen, persönlich" oder "Persönlich, Unternehmen" Bei Kategoriezeichenfolgen wird nicht zwischen Groß- und Kleinschreibung unterschieden. </para>
          <para>Ganze Zahl</para>
          <para>Das Durchsuchen von Feldern vom Typ <b>Integer</b> ist sowohl mit als auch ohne Anführungszeichen und Trennzeichen möglich. Mithilfe folgender Filter wird nach Kontakten gesucht, die in Outlook 2000 erstellt wurden: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = ' 92711 '"</para>
          <para>Verwenden von Variablen in Filtern</para>
          <para>Wie das Beispiel mit der <b>Restrict</b>-Methode zeigt, können Werte aus Variablen als Teil des Filters verwendet werden. Das folgende Microsoft Visual Basic-Codebeispiel veranschaulicht die Syntax, die Variablen als Teil des Filters verwendet. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para>"Dieser Ansatz verwendet Chr (34), um den Wert abzugrenzen. </para>
          <para>sFilter = "[FullName] =" &amp; Chr (34) &amp; sFullName &amp; Chr (34) </para>
          <para>"Dieser Ansatz verwendet doppelte Anführungszeichen, um den Wert abzugrenzen. </para>
          <para>sFilter = "[FullName] =" "" &amp; sFullName &amp; "" ""</para>
          <para>Verwenden von logischen Operatoren als Teil des Filters</para>
          <para>Logische Operatoren, die zulässig sind, sind UND, ODER und NICHT. Es folgen Variationen der Klausel für die <b>Restrict</b> -Methode, sodass Sie mehrere Kriterien angeben können.  </para>
          <para>OR: Der folgende Code gibt alle Kontaktelemente zurück, deren Kategorie entweder "Business" oder "Personal" ist. </para>
          <para>sFilter = "[categories] = ' Personal ' oder [categories] = ' Business '" </para>
          <para>AND: Der folgende Code ruft alle persönlichen Kontakte auf, die bei Microsoft arbeiten. </para>
          <para>sFilter = "[categories] = ' Personal ' und [CompanyName] = ' Microsoft '" </para>
          <para>NOT: Der folgende Code ruft alle persönlichen Kontakte auf, die nicht bei Microsoft arbeiten. </para>
          <para>sFilter = "[categories] = ' Personal" und nicht ([CompanyName] = ' Microsoft ') "</para>
          <para>Zusätzliche Hinweise</para>
          <para>Wenn Sie die <b>Find</b>- oder <b>Restrict</b>-Methode in benutzerdefinierten Feldern verwenden möchten, müssen die Felder im Ordner definiert sein, da andernfalls ein Fehler auftritt. Es gibt keine Möglichkeit, eine "contains"-Operation auszuführen. Sie können z. B. nicht mithilfe der Methode <b>Find</b> oder <b>Restrict</b> nach Elementen suchen, die ein bestimmtes Wort im Feld Betreff enthalten. Stattdessen können Sie die <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> -Methode verwenden, oder Sie können alle Elemente im Ordner durchlaufen und die <b>InStr</b> -Funktion verwenden, um eine Suche in einem Feld durchzuführen. Mithilfe der <b>Restrict</b>-Methode können Sie nach Elementen suchen, die innerhalb eines bestimmten Bereichs von Zeichen beginnen. Verwenden Sie z. B. den folgenden Filter, um nach allen Kontakten mit einem Nachnamen zu suchen, der mit dem Buchstaben "M" beginnt: </para>
          <para>sFilter = "[LastName] &gt; ' LZZZ ' und [LastName] &lt; ' N '"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" /> Objekt für die aktuelle Sitzung zurück. Schreibgeschützt.</summary>
        <value>To be added.</value>
        <remarks><para>Die <b>Session</b> -Eigenschaft und <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> die-Methode können austauschbar verwendet werden, um das <b>Namespace</b> -Objekt für die aktuelle Sitzung abzurufen. Beide Member haben denselben Zweck. Die folgenden Anweisungspaare führen beispielsweise die gleiche Funktion aus:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">Eine Zeichenfolge, die die Namen der zwischenzuspeichernden Eigenschaften enthält. Die Eigenschaftsnamen werden in dieser Zeichenfolge durch Kommas getrennt.</param>
        <summary>Bestimmte Eigenschaften werden für den sehr schnellen Zugriff auf die jeweiligen Eigenschaften eines Elements innerhalb der Auflistung zwischengespeichert.</summary>
        <remarks><para>Die <b></b> SetColumns-Methode eignet sich zum Durchlaufen <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> der Auflistung. Wenn Sie diese Methode nicht verwenden, müssen Microsoft Outlook jedes Element zum Zugriff auf die Eigenschaft öffnen. Mit der <b>SetColumns</b> -Methode überprüft Outlook nur die Eigenschaften, die Sie zwischengespeichert wurden, und ermöglicht den schnellen, schreibgeschützten Zugriff auf diese Eigenschaften.</para>
          <para>Nachdem Sie die <b></b> SetColumns-Methode auf bestimmte Eigenschaften der Auflistung angewendet haben, können Sie andere Eigenschaften dieser Auflistung nicht lesen. Eigenschaften, die nicht zwischengespeichert werden, werden leer zurückgegeben. Sie können auch keine der Eigenschaften dieser Auflistung schreiben. Alternativ können Sie das <see cref="T:Microsoft.Office.Interop.Outlook.Table" /> -Objekt verwenden, wenn Sie Lese-/Schreibzugriff benötigen, Schnellzugriff auf eine Gruppe von Elementen.</para>
          <para>
            <b>SetColumns</b> kann nicht verwendet werden und verursacht einen Fehler, jede Eigenschaft, die ein Objekt zurückgibt. Es kann nicht mit den folgenden Eigenschaften verwendet werden:</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Body</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Kategorien</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Klasse</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Unternehmen</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Gespeichert</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Gesendet</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Übermittelt</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para><b>ConversationIndex</b> -Eigenschaft kann nicht mit der <b>SetColumns</b> -Methode zwischengespeichert werden sollen. Diese Eigenschaft führt jedoch nicht zu einem Fehler wie die oben aufgelisteten Eigenschaften.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">Der Name der Eigenschaft, anhand der sortiert werden soll; dieser kann in Klammer eingeschlossen sein, z. B. "[CompanyName]". Benutzerdefinierte Eigenschaften, die Leerzeichen enthalten, müssen in Klammern eingeschlossen werden. Darf keine benutzerdefinierte Eigenschaft von type-Schlüsselwörtern und keine mehrwertige Eigenschaft, z. B. „category“, sein. Für benutzerdefinierte Eigenschaften muss die-Eigenschaft in der <b>UserDefinedProperties</b> -Auflistung für <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" />vorhanden sein, die das <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> Objekt darstellt, das die Elemente enthält.</param>
        <param name="Descending"><b>True,</b> um in absteigender Reihenfolge zu sortieren. Der Standardwert ist <b>False</b> (aufsteigend).</param>
        <summary>Sorts the collection of items by the specified property. The index for the collection is reset to 1 upon completion of this method.</summary>
        <remarks><para>
            <b>Sort</b> wirkt sich lediglich auf die Reihenfolge der Elemente in einer Auflistung. Es wirkt sich nicht auf die Reihenfolge von Elementen in einem Explorer-Ansicht.</para>
          <para>
            <b>Sort</b> kann nicht verwendet werden und verursacht einen Fehler, wenn <paramref name="property" /> der Parameter eine der folgenden Eigenschaften ist:                </para>
          <list type="table">
            <item>
              <description>
                <b>Kategorien</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Klasse</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Saved</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Gesendet</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
